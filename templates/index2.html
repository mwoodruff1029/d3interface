<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>D3 Test</title>
        <script src="http://d3js.org/d3.v3.min.js"  charset="utf-8"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
        <link rel="stylesheet" href="{{ url_for('static', filename='stylesheets/style.css') }}">
    </head>
    <body>
        <div id="cover"></div>
        <div id="current" class="graphDiv">
            <br>
            <div class="graphHeading">Current Water Use</div>
        </div>
        <div id= "aggregate" class="graphDiv">
            <br>
            <div class="graphHeading">Historical Water Use</div>
        </div>
        <div id="aggButton" class="graphButtonDiv">
            <button class="button" id="hourlyButton">Hourly</button><button class="button" id="dailyButton">Daily</button><button class="button" id="monthlyButton">Monthly</button>
        </div>
        
        <script type="text/javascript">
            
            var width = 900;
            var height = 500;
            var barPadding = 15;
            var heightPadding = 40;
            var widthPadding = 40; 
            var maxVals = Math.round(width/60);            
            
            $(document).ready(function() {
                
                init();
                
                var requestCurrent = $.ajax({
                    url: '/sha/v1.0/readings/current/',
                    data: {"max": maxVals},
                    method: 'GET'
                });
                
                var requestAgg = $.ajax({
                    url: '/sha/v1.0/readings/daily',
                    data: {"max": maxVals},
                    method: 'GET'
                });
                
                requestCurrent.done(function (msg) {
                    drawCurrentGraph(msg.meters);
                });
                
                requestAgg.done(function (msg){
                    drawAggGraph(msg.meters, function () {
                        $("#cover").fadeOut(700);
                    });
                });
                
                // listener for changing the aggregated dataset between
                // daily, hourly, and monthly aggregation
                $('button').on('click', function(){
                    
                    $('button').removeClass('selected');
                    $(this).addClass('selected');
    
                    var type = this.id.replace('Button', '');

                    // get the aggregated dataset of the specific range
                    var requestAgg = $.ajax({
                            url: '/sha/v1.0/readings/' + type,
                            data: {"max": maxVals},
                            method: 'GET'
                    });
                    
                    // when this request is received, update the UI to reflect the
                    // appropriate range
                    requestAgg.done(function (msg){
                        updateAggGraph(msg.meters, type);
                    })
                    
                });
                
            });
            
            function init() {
                // by default, historical graph is aggregated only a daily basis
                $("#dailyButton").addClass('selected');
                
                $(".graphHeading").css("width", width);
                $(".graphButtonDiv").css("width", width+widthPadding/3);
                $(".graphButtonDiv").css("height", heightPadding);
                $(".graphDiv").css("width", width+widthPadding/3);
                
            }
            
            function drawCurrentGraph(dataset){
                
                function getXLoc(d,i){
                    return scaleTime(new Date(d.timestamp));
                }
                
                var widthIn = ((width-widthPadding)/dataset.length)/2;

                var scaleTime = d3.time.scale()
                    .domain([new Date(dataset[dataset.length-1].timestamp), new Date(dataset[0].timestamp)])
                    .range([widthPadding, width-widthPadding/2]);
                
                var scaleHeight = d3.scale.linear()
                    .domain([0, d3.max(dataset, function(d) {return Math.max(d.outdoor, d.indoor);})])
                    .range([0, height-heightPadding*2]);
                
                var scaleHeightUpsideDown = d3.scale.linear()
                    .domain([0, d3.max(dataset, function(d){ return Math.max(d.outdoor,d.indoor);})])
                    .range([height-heightPadding*2, 0]);
                
                var svgCurrent = d3.select("#current")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                 var yAxis = d3.svg.axis()
                    .scale(scaleHeightUpsideDown)
                    .orient("left")
                    .ticks(5);
                
                var xAxis = d3.svg.axis()
                    .scale(scaleTime)
                    .orient("bottom")
                    .ticks(dataset.length);
                
                svgCurrent.append("g")
                    .attr("class", "x axis")
                    .call(xAxis)
                    .attr("transform", "translate(" + 0 + "," + (height-heightPadding) + ")");
                
                svgCurrent.append("g")
                    .attr("class", "y axis")
                    .attr("transform", "translate("+ widthPadding + "," + heightPadding + ")")
                    .call(yAxis);
                
                // add the gridlines
                svgCurrent.selectAll("line.horizontalGrid")
                    .data(scaleHeightUpsideDown.ticks(5))
                    .enter()
                    .append("line")
                        .attr(
                        {
                            "class":"horizontalGrid",
                            "x1" : widthPadding,
                            "x2" : width - widthPadding/2,
                            "y1" : function(d){ return scaleHeightUpsideDown(d) + heightPadding;},
                            "y2" : function(d){ return scaleHeightUpsideDown(d) + heightPadding;},
                            "fill" : "none",
                            "shape-rendering" : "crispEdges",
                            "stroke" : "white",
                            "stroke-width" : "1px",
                            "stroke-dasharray" : "5, 5"
                        });
                
                // add the outdoor data points
                svgCurrent.selectAll("#outdoorCircle")
                    .data(dataset)
                    .enter()
                    .append("circle")
                    .attr({
                        "cx": function(d,i){return getXLoc(d,i);},
                        "cy": function(d){ 
                            return height - scaleHeight(d.outdoor) - heightPadding;
                        },
                        "r": 8,
                        "id": "outdoorCircle",
                        "class": "outdoor"
                    });
                
                // add the indoor data points
                svgCurrent.selectAll("#indoorCircle")
                    .data(dataset)
                    .enter()
                    .append("circle")
                    .attr({
                        "cx": function(d,i){return getXLoc(d,i);},
                        "cy": function(d){ return height - scaleHeight(d.indoor) - heightPadding;},
                        "r": 8,
                        "id": "indoorCircle",
                        "class": "indoor"
                    });
                
                // function for adding the connection between points
                var valueInd = d3.svg.line()
                    .x(function(d, i) { 
                        return getXLoc(d,i);
                    })
                    .y(function(d){return height - scaleHeight(d.indoor) - heightPadding;});
                
                var valueOut = d3.svg.line()
                    .x(function(d, i) { 
                        return getXLoc(d,i);
                    })
                    .y(function(d){return height - scaleHeight(d.outdoor) - heightPadding;});
                
                // append the paths between points
                svgCurrent.append("path")
                    .attr("class", "indoorPath")
                    .attr("d", valueInd(dataset));
                
                svgCurrent.append("path")
                    .attr("class", "outdoorPath")
                    .attr("d", valueOut(dataset));
                
               
                addYLabel(svgCurrent);
                
    
            }
            
            function drawAggGraph(dataset, callback) {
                
                var lastDate = getAdjustedDate(dataset[0].timestamp); 
                //console.log(lastDate);
                var firstDate = getAdjustedDate(dataset[dataset.length-1].timestamp);
                
                // note, this only works for daily readings, what we're doing rn
                lastDate.setDate(lastDate.getDate() + 1);
                
                var scaleTime = d3.time.scale()
                    .domain([firstDate, lastDate])
                    .range([widthPadding, width-widthPadding/2]);
                
                var scaleHeight = d3.scale.linear()
                    .domain([0, d3.max(dataset, function(d){ return (d.outdoor+d.indoor);})])
                    .range([0, height-heightPadding*2]);

                var scaleHeightUpsideDown = d3.scale.linear()
                    .domain([0, d3.max(dataset, function(d){ return (d.outdoor+d.indoor);})])
                    .range([height-heightPadding*2, 0]);
                
                var svgAgg = d3.select("#aggregate")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                svgAgg.selectAll("line.horizontalGrid")
                    .data(scaleHeightUpsideDown.ticks(5))
                    .enter()
                    .append("line")
                        .attr(
                        {
                            "class":"horizontalGrid",
                            "x1" : widthPadding,
                            "x2" : width - widthPadding/2,
                            "y1" : function(d){ return scaleHeightUpsideDown(d) + heightPadding;},
                            "y2" : function(d){ return scaleHeightUpsideDown(d) + heightPadding;},
                            "fill" : "none",
                            "shape-rendering" : "crispEdges",
                            "stroke" : "white",
                            "stroke-width" : "1px",
                            "stroke-dasharray" : "5, 5"
                        });
                
                svgAgg.selectAll("#outdoorRect")
                    .data(dataset)
                    .enter()
                    .append("rect")
                    .attr({
                        "x": function(d,i){
                            var date = getAdjustedDate(d.timestamp);
                            return scaleTime(date);
                        },
                        "y": function (d){
                            return height - scaleHeight(d.outdoor) - scaleHeight(d.indoor) - heightPadding;   
                        },
                        "width": (width-widthPadding/2)/dataset.length - barPadding,
                        "height": function(d){
                            return scaleHeight(d.outdoor);
                        },
                        "id": "outdoorRect",
                        "class": "outdoor"
                    });
                
                svgAgg.selectAll("#indoorRect")
                    .data(dataset)
                    .enter()
                    .append("rect")
                    .attr({
                        "x": function(d,i){
                            date = getAdjustedDate(d.timestamp);
                            return scaleTime(date);
                        },
                        "y": function (d){
                            return height - scaleHeight(d.indoor) - heightPadding;   
                        },
                        "width": (width-widthPadding/2)/dataset.length - barPadding,
                        "height": function(d){
                            return scaleHeight(d.indoor);
                        },
                        "id": "indoorRect",
                        "class": "indoor"
                    });
                
                svgAgg.selectAll(".barText")
                    .data(dataset)
                    .enter()
                    .append("text")
                    .text(function(d){
                        return (d.indoor + d.outdoor).toFixed(2);
                    })
                    .attr("x", function(d){
                        var date = getAdjustedDate(d.timestamp);
                        return scaleTime(date) + ((width-widthPadding/2)/dataset.length - barPadding)/2;
                    })
                    .attr("y", function(d){
                        return height - scaleHeight(d.indoor) - scaleHeight(d.outdoor) - heightPadding*4/3;
                    })
                    .attr("class", "barText")
                    .attr("text-anchor", "middle");
                
                var yAxis = d3.svg.axis()
                    .scale(scaleHeightUpsideDown)
                    .orient("left")
                    .ticks(5);
                
                var xAxis = d3.svg.axis()
                    .scale(scaleTime)
                    .orient("bottom")
                    .ticks(dataset.length + 1);
                
                svgAgg.append("g")
                    .attr("class", "y axis")
                    .attr("transform", "translate("+ widthPadding + "," + heightPadding + ")")
                    .call(yAxis);
                
                svgAgg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(" + 0 + "," + (height-heightPadding) + ")")
                    .call(xAxis);
                    
                
                addYLabel(svgAgg);
                
                callback();
            
                function getAdjustedDate(timestamp){
                    var date = new Date(timestamp);
                    date.setHours(24,0,0,0);
                    return date;
                }
                
            }
            
            function updateAggGraph(dataset,type){
                var lastDate = getAdjustedDate(dataset[0].timestamp, type, true); 
                //console.log(lastDate);
                var firstDate = getAdjustedDate(dataset[dataset.length-1].timestamp, type, false);
                //console.log(firstDate);
                
                
                var scaleTime = d3.time.scale()
                    .domain([firstDate, lastDate])
                    .range([widthPadding, width-widthPadding/2]);
                
                var scaleHeight = d3.scale.linear()
                    .domain([0, d3.max(dataset, function(d){ return (d.outdoor+d.indoor);})])
                    .range([0, height-heightPadding*2]);

                var scaleHeightUpsideDown = d3.scale.linear()
                    .domain([0, d3.max(dataset, function(d){ return (d.outdoor+d.indoor);})])
                    .range([height-heightPadding*2, 0]);
                
                var yAxis = d3.svg.axis()
                    .scale(scaleHeightUpsideDown)
                    .orient("left")
                    .ticks(5);
                
                var xAxis = d3.svg.axis()
                    .scale(scaleTime)
                    .orient("bottom")
                    .ticks(dataset.length + 1);
                
                var svgAgg = d3.select("#aggregate svg");
                
            
                // associate the bars, indoor rectangles and outdoor rectangles with the
                // new dataset
                var indoorRects = svgAgg.selectAll("#indoorRect")
                    .data(dataset);
                var outdoorRects = svgAgg.selectAll("#outdoorRect")
                    .data(dataset);
                var barText = svgAgg.selectAll(".barText")
                    .data(dataset);
                var graphLines = svgAgg.selectAll("line.horizontalGrid")
                    .data(scaleHeightUpsideDown.ticks(5));
                
                // remove unnecessary objects and add now needed ones
                indoorRects.exit().remove();
                indoorRects.enter().append("rect").attr({"width": 0, "height":0});

                outdoorRects.exit().remove();
                outdoorRects.enter().append("rect").attr({"width": 0, "height":0});
                
                barText.exit().remove();
                barText.enter().append("text").text("0");
                
                graphLines.exit().remove();
                graphLines.enter().append("line").moveToBack();
                
                // transition text/bars to their new values
                graphLines.transition()
                    .duration(750)
                    .attr(
                        {
                            "class":"horizontalGrid",
                            "x1" : widthPadding,
                            "x2" : width - widthPadding/2,
                            "y1" : function(d){ return scaleHeightUpsideDown(d) + heightPadding;},
                            "y2" : function(d){ return scaleHeightUpsideDown(d) + heightPadding;},
                            "fill" : "none",
                            "shape-rendering" : "crispEdges",
                            "stroke" : "white",
                            "stroke-width" : "1px",
                            "stroke-dasharray" : "5, 5"
                        });
                
                barText.transition()
                    .duration(750)
                    .text(function(d){
                        return (d.indoor + d.outdoor).toFixed(2);
                    })
                    .attr("x", function(d){
                        var date = getAdjustedDate(d.timestamp, type);
                        return scaleTime(date) + ((width-widthPadding/2)/dataset.length - barPadding)/2;
                    })
                    .attr("y", function(d){
                        return height - scaleHeight(d.indoor) - scaleHeight(d.outdoor) - heightPadding*4/3;
                    })
                    .attr("class", "barText")
                    .attr("text-anchor", "middle");
                
                // update existing ones
                indoorRects.transition()
                    .duration(750)
                    .attr({
                        "x": function(d,i){
                            date = getAdjustedDate(d.timestamp, type);
                            return scaleTime(date);
                        },
                        "y": function (d){
                            return height - scaleHeight(d.indoor) - heightPadding;   
                        },
                        "width": (width-widthPadding/2)/dataset.length - barPadding,
                        "height": function(d){
                            return scaleHeight(d.indoor);
                        },
                        "id": "indoorRect",
                        "class": "indoor"
                    });
                
                outdoorRects.transition()
                    .duration(750)
                    .attr({
                        "x": function(d,i){
                            var date = getAdjustedDate(d.timestamp, type);
                            return scaleTime(date);
                        },
                        "y": function (d){
                            return height - scaleHeight(d.outdoor) - scaleHeight(d.indoor) - heightPadding;   
                        },
                        "width": (width-widthPadding/2)/dataset.length - barPadding,
                        "height": function(d){
                            return scaleHeight(d.outdoor);
                        },
                        "id": "outdoorRect",
                        "class": "outdoor"
                    });
                
                svgAgg.selectAll(".x.axis")                    // change the x axis
                   .transition()
                    .duration(750)
                    .call(xAxis);
                svgAgg.selectAll(".y.axis") // change the y axis
                    .transition()
                    .duration(750)
                    .call(yAxis);
                
                svgAgg.select(".yLabel").moveToFront();
                
            
                function getAdjustedDate(timestamp, type, last){
                    var date = new Date(timestamp);
                    
                    if (type == 'daily') {
                        date.setHours(24,0,0,0);
                        if (last) date.setDate(date.getDate() + 1);
                    }
                    
                    if (type == 'hourly'){
                        if (last) date.setHours(date.getHours() + 1);
                    }
                    
                    return date;
                }
                
            }
            
            function addYLabel(svg){
                svg.append("text")
                    .attr("class", "yLabel")
                    .attr("text-anchor", "start")
                    .attr("y", widthPadding + widthPadding/8)
                    .attr("x", -(height-heightPadding-5))
                    .attr("dy", ".75em")
                    .attr("transform", "rotate(-90)")
                    .text("Gallons");
            }
            
            // This method at the suggestion of user Sundar on bl.ocks.org
            // link: http://bl.ocks.org/eesur/4e0a69d57d3bfc8a82c2
            d3.selection.prototype.moveToBack = function() {  
                return this.each(function() { 
                    var firstChild = this.parentNode.firstChild; 
                    if (firstChild) { 
                        this.parentNode.insertBefore(this, firstChild); 
                    } 
                });
            };
            
            // https://github.com/wbkd/d3-extended
            d3.selection.prototype.moveToFront = function() {  
              return this.each(function(){
                this.parentNode.appendChild(this);
              });
            };
            
        </script>
    </body>
</html>